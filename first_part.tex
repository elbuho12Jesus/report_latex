\section{First Part (Rigid structure from motion by factorization)}
\noindent In this task, I must complete the orthogonal factorization function (\textbf{rigidfactorization ortho.m}). Also, we run the code with the provided example (a synthetic sequence with an ogre is provided to you) and report the 3D reconstruction error.\\

\noindent In this task, factorization for a rigid body must be implemented, as shown in the following slide figure \ref{fig:slideT1}:

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{T1/slide}
    \caption{Factoring slide}
    \label{fig:slideT1}
\end{figure}

\subsection{Code:}
\noindent Now we introduce the code, we will explain each line number, but first I want to mention that the value of $Zc$ is not the input matrix, but this is the input matrix minus the average of all the points in each frame. This way we no longer have to consider translation in the calculations.\\ 
\noindent Therefore the average matrix would be the following (with a dimension of $2f\times p$):
\begin{equation}\label{eq:mean}
Mean=
\begin{pmatrix}
Mean_{1} & Mean_{1} & \cdots Mean_{1}\\
Mean_{2} & Mean_{2} & \cdots Mean_{2}\\
\vdots & \vdots & \ddots & \vdots\\
Mean_{f} & Mean_{f} & \cdots Mean_{f}
\end{pmatrix}
\end{equation}
\noindent where
\begin{equation}
Media_{k}=
\begin{pmatrix}
\frac{x_{1} + x_{2} + \cdots + x_{p}}{p}\\
\frac{y_{1} + y_{2} + \cdots + y_{p}}{p}
\end{pmatrix}
\end{equation}
\noindent for any $k$ between $1$ and $f$.
\noindent Therefore from \ref{eq:mean} we have:
\begin{equation}
Zc=Input-Mean
\end{equation}
\noindent Having said this, we continue with the application of the code figure \ref{fig:codeT1}.\\

\noindent In the first line, we calculate the factorization called Singular value decomposition(SVD).\\

\noindent In the second line, we approximate $R=U(:,1:3)D(1:3, 1:3)^{1/2}$ and $S=D(1:3, 1:3)^{1/2}V(:, 1:3)'$ (where $R$ represents rotation and $S$ represents shape) in such a way that we only take the first three columns of U and, the first three columns of V and, the first three rows and the first three columns of D. This is because, being a rigid body, the range of $R$ and $S$ is 3.\\

\noindent In the "while loop" we try to reduce $\Vert Zc-RU\Vert$ to the threshold (in the code is epsilon). The idea is to use the rotation condition ($R_{i}R_{i}'=I$ where $I$ is identity matrix) which is used to calculate $T$ in the code and thus be able to calculate the new matrices $S$ and $R$.


\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{T1/code}
    \caption{source code}
    \label{fig:codeT1}
\end{figure}

\subsection{Examples:}
\noindent Here we will show how to reconstruct the face of an Ogre with the given frames and using the following input parameters:

\begin{itemize}
\item threholder: $10^{-7}$
\item maximum number of iterations: 200
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{T1/figure1}
    \caption{the original face of the Ogre.}
    \label{fig:real_ogre}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{T1/figure3}
    \caption{The Ogre's face reconstructed with the algorithm.}
    \label{fig:ogre}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{T1/figure2}
    \caption{Comparison between the 3D representation of the Ogre's face against the one reconstructed by the algorithm.}
    \label{fig:real_ogre_vs_ogre}
\end{figure}
\noindent As can be seen in Figure \ref{fig:real_ogre_vs_ogre}, the reconstruction of the ogre's face is quite good, the error between the real ogre and the reconstructed one is quite low Figure \ref{fig:3d_error}.
\begin{figure}[h]
    \centering
    \includegraphics[width=0.4\textwidth]{T1/3derror}
    \caption{Error between the ogre's face and the reconstructed face.}
    \label{fig:3d_error}
\end{figure}
